d√©ployer un site
sur OVH on doit choisir pour backend si on W en php ou not JS. apr√®s valable POUR TOUS LES SITES sinon on doit reprendre une option
avec file zilla

dockers : cr√©e une config pc pareille pour tt le monde qui W √† un projet

Avec plaisir ! Les getters (get) et setters (set) sont des m√©thodes en programmation orient√©e objet (POO) qui permettent d‚Äôacc√©der ou de modifier les propri√©t√©s d‚Äôun objet de mani√®re contr√¥l√©e.

üîí Pourquoi les utiliser ?
Imaginons que tu as une propri√©t√© priv√©e comme √ßa :

php
Copier le code
class Personne {
    private $nom;
}
Comme $nom est priv√©e, on ne peut pas y acc√©der directement depuis l‚Äôext√©rieur de la classe. D‚Äôo√π l‚Äôint√©r√™t de :

getNom() ‚Üí pour lire la valeur

setNom($valeur) ‚Üí pour modifier la valeur

üß† Exemple simple en PHP :
php
Copier le code
class Personne {
    private $nom;

    public function getNom() {
        return $this->nom;
    }

    public function setNom($nouveauNom) {
        $this->nom = $nouveauNom;
    }
}
üß™ Utilisation :
php
Copier le code
$p = new Personne();
$p->setNom("Alice");
echo $p->getNom(); // Affiche : Alice
‚úÖ Avantages des getters/setters :
S√©curit√© : tu peux contr√¥ler ce qu‚Äôon met ou r√©cup√®re.

Validation : tu peux v√©rifier les donn√©es avant de les accepter.

Flexibilit√© : tu peux changer l‚Äôimpl√©mentation interne plus tard sans casser le code qui utilise la classe.

üéØ Exemple avec validation :
php
Copier le code
public function setNom($nouveauNom) {
    if (strlen($nouveauNom) > 0) {
        $this->nom = $nouveauNom;
    } else {
        echo "Nom invalide";
    }
}
GET SET
Qd on pose les get et set avec $var=$a d√©clar√©e
getVar() avec return $this->var MAIS setVar($a) avec return $this->var=$a
Qd on appelle les getter et setter
GET ::: pas de param√®tre car on a d√©clar√© des var avant PAS DE MODIFICATIONS/ v√©rif juste appeler une variable PAS DE IF
SET ::: modifier la donn√©e => on rajoute un/ des param√®tres DES VERIFS / IF donc on peut appeler la Fo directement ds Fo __construct ($this-> setMachin($a) )

avec GET et SET mettre return si on doit afficher la val.

boolean : par d√©faut c'est true

{} avec "" et non '' pour ex:echo "le livre {$this->getTitre()} est √† nouveau dispo";

public
private -->SANS GETTER (ET SETTER) on ne peut pas r√©cup√©rer la var ===on ne peut pas faire echo $classe1->var; CA FAIT FATAL ERROR
class Classe{private $var} 
$classe1 = new Classe 

EX :: ?? explications mu ??
class Produit{ 				//objet Produit
    private string $nom;	// $nom attribut/propri√©t√©
    private int $stock;	
    private float $prix;

    public function __construct(string $a, int $b, float $c) // (string $a, int $b, float $c) == param√®tres
    {
        $this->nom = $a;    // $this instanciationde Produit ==Nx nom
        $this->stock = $b;
        $this->prix = $c;
    }

round (r√©sultat, chiffre)-->arrondir (r√©sultat) √† (chiffre) apr√®s la virgule


 	  /\
	 /  \
	/    \
 ____

ds VScode  > menu pricipal >s√©lection>mode selection colonne et √ßa fait c√¥ ctrl ALT + fleches >>> pour s√©lection +sieurs lignes

Utilisez include() lorsque le fichier n'est pas essentiel, comme un √©l√©ment de mod√®le. Utilisez require() lorsque le fichier est vital, comme un fichier de configuration. Utilisez include_once() ou require_once() pour garantir qu'un fichier n'est inclus qu'une seule fois, comme une d√©finition de classe 

QUAND √ßA NE MARCHE PAS ET PAS D4EXPLICATIONS ::: noms des class peut ^tre ds un dossier pas loin et √ßa bloque


